<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Nexus-Net - <%= plan.name %></title>
    
    <script type="text/javascript" src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* --- THEME UNIVERSAL --- */
        :root {
            --bg-color: #0f172a;
            --panel-bg: rgba(30, 41, 59, 0.96);
            --border-color: rgba(148, 163, 184, 0.2);
            --accent-blue: #38bdf8; 
            --accent-purple: #c084fc;
            --accent-green: #4ade80;
            --accent-red: #f87171;
            --accent-orange: #fbbf24;
            --docker-blue: #2496ED;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
        }

        body {
            margin: 0; height: 100vh; overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            display: flex;
        }

        .grid-bg {
            background-size: 40px 40px;
            background-image:
                linear-gradient(to right, rgba(51, 65, 85, 0.5) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(51, 65, 85, 0.5) 1px, transparent 1px);
        }

        /* --- UI HELPERS --- */
        .btn { padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 12px; display: flex; align-items: center; justify-content: center; gap: 8px; transition: 0.2s; }
        .btn-primary { background: linear-gradient(135deg, var(--accent-blue), #2563eb); color: white; box-shadow: 0 4px 10px rgba(56, 189, 248, 0.3); }
        .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 6px 15px rgba(56, 189, 248, 0.5); }
        
        .btn-ghost { background: rgba(255,255,255,0.05); border: 1px solid var(--border-color); color: var(--text-secondary); }
        .btn-ghost:hover { background: rgba(255,255,255,0.1); color: white; border-color: var(--accent-blue); }
        
        .btn-drawio { background: #f08705; color: white; border: 1px solid #d97706; }
        .btn-drawio:hover { background: #d97706; }
        
        .btn-danger { background: linear-gradient(135deg, var(--accent-red), #dc2626); color: white; box-shadow: 0 4px 10px rgba(248, 113, 113, 0.3); }
        .btn-danger:hover { transform: translateY(-1px); box-shadow: 0 6px 15px rgba(248, 113, 113, 0.5); }

        .btn-icon { padding: 8px; width: 36px; height: 36px; font-size: 16px; border-radius: 6px; }
        .btn-icon.active { background: var(--accent-blue); color: white; border-color: var(--accent-blue); }

        input, select { width: 100%; padding: 10px; background: rgba(0,0,0,0.3); border: 1px solid var(--border-color); border-radius: 6px; color: var(--text-primary); font-family: 'Inter', sans-serif; font-size: 13px; box-sizing: border-box; margin-bottom: 8px; }
        input:focus { outline: none; border-color: var(--accent-blue); background: rgba(0,0,0,0.5); }
        label { font-size: 11px; color: var(--text-secondary); display: block; margin-bottom: 4px; font-weight: 700; text-transform: uppercase; letter-spacing: 0.5px; }

        /* --- DRAG & DROP OVERLAY --- */
        #dropZone {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.95); z-index: 999; display: none;
            align-items: center; justify-content: center; flex-direction: column;
            border: 5px dashed var(--accent-blue); box-sizing: border-box;
        }
        #dropZone h1 { color: var(--accent-blue); font-size: 30px; pointer-events: none; }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 300px; background: var(--panel-bg); border-right: 1px solid var(--border-color);
            padding: 25px; display: flex; flex-direction: column; gap: 15px; z-index: 100; 
            box-shadow: 10px 0 30px rgba(0,0,0,0.5); overflow-y: auto;
        }
        h2 { margin: 0; font-size: 20px; font-weight: 800; display: flex; align-items: center; gap: 10px; color: var(--text-primary); letter-spacing: -1px; }
        .section-header { font-size: 11px; font-weight: 800; color: var(--accent-blue); text-transform: uppercase; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; margin-top: 15px; margin-bottom: 10px; display:flex; justify-content:space-between; align-items:center;}

        /* --- INSPECTOR --- */
        #inspector {
            position: absolute; top: 20px; right: 20px; width: 280px;
            background: var(--panel-bg); backdrop-filter: blur(10px);
            border: 1px solid var(--border-color); border-radius: 12px; padding: 20px;
            display: none; box-shadow: 0 10px 40px rgba(0,0,0,0.7); z-index: 50;
            border-left: 4px solid var(--accent-purple);
        }
        
        #ruler-top {
            position: absolute; top: 0; left: 0; width: 100%; height: 20px;
            background: rgba(15, 23, 42, 0.8); border-bottom: 1px solid var(--border-color);
            z-index: 10; pointer-events: none;
        }
        #ruler-left {
            position: absolute; top: 0; left: 0; width: 20px; height: 100%;
            background: rgba(15, 23, 42, 0.8); border-right: 1px solid var(--border-color);
            z-index: 10; pointer-events: none;
        }
        #ruler-corner {
            position: absolute; top: 0; left: 0; width: 20px; height: 20px;
            background: rgba(15, 23, 42, 0.95); z-index: 15; pointer-events: none;
            display: flex; align-items: center; justify-content: center;
            font-size: 7px; font-family: 'JetBrains Mono', monospace;
            color: rgba(148, 163, 184, 0.4);
            border-right: 1px solid var(--border-color);
            border-bottom: 1px solid var(--border-color);
        }

        #workspace-wrapper { flex-grow: 1; position: relative; overflow: hidden; }
        #network-container { width: 100%; height: 100%; }
        #customUploadArea { display: none; padding: 10px; border: 1px dashed var(--accent-blue); background: rgba(56, 189, 248, 0.1); border-radius: 4px; margin-bottom: 10px;}
        
        #toast {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: var(--accent-green); color: #064e3b; padding: 10px 25px; border-radius: 30px;
            font-weight: 700; opacity: 0; transition: 0.3s; pointer-events: none; z-index: 900;
        }

        /* --- LIBRARY GRID --- */
        .category-header {
            font-size: 10px; font-weight: 700; color: var(--text-secondary);
            text-transform: uppercase; margin-top: 15px; margin-bottom: 8px;
            letter-spacing: 1px;
        }
        .item-grid {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;
        }
        .item-btn {
            background: rgba(255,255,255,0.03); border: 1px solid var(--border-color);
            border-radius: 6px; padding: 10px 5px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; gap: 5px;
            transition: 0.2s; color: var(--text-secondary);
        }
        .item-btn:hover {
            background: rgba(255,255,255,0.1); border-color: var(--accent-blue);
            color: white; transform: translateY(-2px);
        }
        .item-btn i { font-size: 18px; margin-bottom: 4px; }
        .item-btn span { font-size: 9px; font-weight: 600; }
        .docker-icon { color: var(--docker-blue) !important; }
        
        /* --- MINIMAP --- */
        #minimap {
            position: absolute; bottom: 20px; right: 20px; width: 200px; height: 150px;
            background: var(--panel-bg); backdrop-filter: blur(10px);
            border: 1px solid var(--border-color); border-radius: 8px; z-index: 40;
            padding: 5px; display: flex; flex-direction: column;
        }
        #minimap-canvas {
            width: 100%; height: 100%; border-radius: 4px;
            background: rgba(0,0,0,0.3); cursor: pointer;
        }
        #minimap-header {
            font-size: 9px; font-weight: 700; color: var(--text-secondary);
            text-transform: uppercase; padding: 5px; letter-spacing: 0.5px;
        }
        
        /* --- LEGEND --- */
        #legend {
            position: absolute; top: 20px; left: 320px; min-width: 180px;
            background: var(--panel-bg); backdrop-filter: blur(10px);
            border: 1px solid var(--border-color); border-radius: 8px; z-index: 40;
            padding: 15px; max-height: 400px; overflow-y: auto;
        }
        #legend.collapsed { height: auto; max-height: none; }
        #legend-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 10px; cursor: pointer;
        }
        #legend-header h3 {
            margin: 0; font-size: 12px; font-weight: 700; color: var(--text-primary);
        }
        #legend-content {
            display: flex; flex-direction: column; gap: 8px;
        }
        .legend-item {
            display: flex; align-items: center; gap: 10px; font-size: 11px;
            color: var(--text-secondary);
        }
        .legend-item i {
            font-size: 16px;
        }
        
        /* --- STATISTICS --- */
        #statistics {
            position: absolute; bottom: 20px; left: 320px; min-width: 220px;
            background: var(--panel-bg); backdrop-filter: blur(10px);
            border: 1px solid var(--border-color); border-radius: 8px; z-index: 40;
            padding: 15px;
        }
        #statistics h3 {
            margin: 0 0 10px 0; font-size: 12px; font-weight: 700;
            color: var(--text-primary);
        }
        .stat-item {
            display: flex; justify-content: space-between; align-items: center;
            padding: 6px 0; border-bottom: 1px solid var(--border-color);
            font-size: 11px;
        }
        .stat-item:last-child { border-bottom: none; }
        .stat-label { color: var(--text-secondary); }
        .stat-value { color: var(--text-primary); font-weight: 700; }
        
        /* --- NAVIGATION CONTROLS --- */
        #nav-controls {
            position: absolute; top: 20px; right: 320px;
            display: flex; flex-direction: column; gap: 8px; z-index: 40;
        }
        #nav-controls button {
            width: 40px; height: 40px; border-radius: 8px;
            background: var(--panel-bg); border: 1px solid var(--border-color);
            color: var(--text-secondary); font-size: 16px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: 0.2s;
        }
        #nav-controls button:hover {
            background: rgba(255,255,255,0.1); color: white;
            border-color: var(--accent-blue);
        }
    </style>
</head>
<body>

    <div id="dropZone">
        <i class="fas fa-file-import" style="font-size: 60px; color: var(--accent-blue); margin-bottom: 20px;"></i>
        <h1>Lâchez pour Ouvrir</h1>
    </div>

    <div id="toast">Projet Sauvegardé</div>

    <div id="sidebar">
        <a href="/dashboard" class="btn-ghost" style="text-decoration:none; display:flex; align-items:center; gap:5px; margin-bottom: 10px; padding: 8px; justify-content: center;">
            <i class="fas fa-arrow-left"></i> Retour Dashboard
        </a>

        <h2><i class="fas fa-globe" style="color:var(--accent-green)"></i> NEXUS NET</h2>
        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 10px;"><%= plan.name %></div>

        <div style="background: rgba(255,255,255,0.05); padding: 8px; border-radius: 6px; display:flex; align-items:center; margin-bottom: 15px; border: 1px solid var(--border-color);">
            <i class="fas fa-search" style="color: #64748b; margin-right: 8px;"></i>
            <input type="text" id="searchNode" placeholder="Rechercher..." style="width: 100%; border:none; background:transparent; color:white; margin:0; padding:0;" oninput="searchNetwork()">
        </div>
        
        <div class="category-header">Outils de Vue</div>
        <div class="item-grid" style="grid-template-columns: repeat(3, 1fr); margin-bottom: 15px;">
             <button class="item-btn" onclick="network.fit()" title="Recentrer"><i class="fas fa-compress-arrows-alt"></i><span>Centrer</span></button>
             <button class="item-btn" onclick="toggleGrid()" title="Grille"><i class="fas fa-border-all"></i><span>Grille</span></button>
             <button class="item-btn" onclick="toggleLinkMode()" id="btnLinkMode" title="Mode Liaison"><i class="fas fa-bezier-curve"></i><span>Lier</span></button>
             <button class="item-btn" onclick="toggleMagnet()" id="btnMagnet" title="Aimant"><i class="fas fa-magnet"></i><span>Aimant</span></button>
             <button class="item-btn" onclick="alignNodes('UD')" title="Aligner Verticalement"><i class="fas fa-arrows-alt-v"></i><span>Align V</span></button>
             <button class="item-btn" onclick="alignNodes('LR')" title="Aligner Horizontalement"><i class="fas fa-arrows-alt-h"></i><span>Align H</span></button>
        </div>
        
        <div class="section-header">Bibliothèque</div>
        
        <div style="margin-bottom: 15px;">
            <input type="text" id="nodeLabel" placeholder="Nom (optionnel)" style="margin-bottom:5px;">
            <input type="text" id="nodeIP" placeholder="IP (optionnel)">
            <div style="margin-top:5px;">
                <label style="margin:0; font-size:10px; color:var(--text-secondary);">Couleur</label>
                <div id="colorPalette" style="display:flex; gap:5px; flex-wrap:wrap; margin-top:5px;"></div>
                <input type="hidden" id="nodeColor" value="#38bdf8">
            </div>
        </div>

        <div class="category-header">Infrastructure</div>
        <div class="item-grid">
            <div class="item-btn" onclick="addNode('server')"><i class="fas fa-server"></i><span>Serveur</span></div>
            <div class="item-btn" onclick="addNode('router')"><i class="fas fa-network-wired"></i><span>Routeur</span></div>
            <div class="item-btn" onclick="addNode('switch')"><i class="fas fa-microchip"></i><span>Switch</span></div>
            <div class="item-btn" onclick="addNode('firewall')"><i class="fas fa-shield-halved"></i><span>Firewall</span></div>
            <div class="item-btn" onclick="addNode('cloud')"><i class="fas fa-cloud"></i><span>Internet</span></div>
            <div class="item-btn" onclick="addNode('db')"><i class="fas fa-database"></i><span>Data</span></div>
            <div class="item-btn" onclick="addNode('docker')"><i class="fab fa-docker docker-icon"></i><span>Docker</span></div>
        </div>

        <div class="category-header">Utilisateurs</div>
        <div class="item-grid">
            <div class="item-btn" onclick="addNode('pc')"><i class="fas fa-desktop"></i><span>PC</span></div>
            <div class="item-btn" onclick="addNode('printer')"><i class="fas fa-print"></i><span>Print</span></div>
            <div class="item-btn" onclick="addNode('wifi')"><i class="fas fa-wifi"></i><span>Wifi</span></div>
        </div>

        <div class="category-header">Outils</div>
        <div class="item-grid">
            <div class="item-btn" onclick="addNode('note')"><i class="fas fa-sticky-note"></i><span>Note</span></div>
            <div class="item-btn" onclick="document.getElementById('customImg').click()"><i class="fas fa-image"></i><span>Image</span></div>
        </div>
        <input type="file" id="customImg" accept="image/*" style="display:none;">

        <div class="section-header">Docker</div>
        <button class="btn-primary" onclick="importFromDocker()" style="width:100%; justify-content:center;">
            <i class="fab fa-docker"></i> Importer depuis Docker
        </button>

        <div class="section-header">
            Connexion
            <button class="btn-ghost" onclick="connectSelectedNodes()" title="Lier sélection" style="padding: 4px 8px; font-size:10px;">
                <i class="fas fa-bolt" style="color:var(--accent-orange)"></i>
            </button>
        </div>

        <div style="display:flex; gap:5px;">
            <select id="fromNode"><option>Src...</option></select>
            <select id="toNode"><option>Dst...</option></select>
        </div>
        <button class="btn-ghost" onclick="addEdge()" style="width:100%; justify-content:center;">
            <i class="fas fa-link"></i> CONNECTER
        </button>

        <div class="section-header">Exports</div>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:8px;">
            <button class="btn-ghost" onclick="savePlan(true)"><i class="fas fa-save"></i> Save</button>
            <button class="btn-ghost" onclick="triggerLoad()"><i class="fas fa-folder-open"></i> Ouvrir</button>
            <button class="btn-drawio" onclick="exportDrawIO()" style="grid-column: span 2;">
                <i class="fas fa-shapes"></i> Export vers Draw.io
            </button>
            <button class="btn-ghost" onclick="exportJSON()">JSON</button>
            <button class="btn-ghost" onclick="exportPDF()">PDF</button>
        </div>
        
        <input type="file" id="fileLoader" style="display:none;" onchange="loadJSONFromFile(this)">
    </div>

    <div id="workspace-wrapper">
        <div id="network-container" class="grid-bg"></div>
        <div id="selectionBox" style="position:absolute; border:1px solid #38bdf8; background:rgba(56, 189, 248, 0.2); display:none; pointer-events:none; z-index:1000;"></div>
        <div id="ruler-corner">px</div>
        <canvas id="ruler-top"></canvas>
        <canvas id="ruler-left"></canvas>
    </div>

    <div id="inspector">
        <div id="insp-content-node" style="display:none;">
            <div class="section-header" style="margin-top:0">Modifier Appareil</div>
            
            <label>Nom</label>
            <input type="text" id="edit-name" oninput="updateNode()">
            <label>IP</label>
            <input type="text" id="edit-ip" oninput="updateNode()">
            <label>Couleur</label>
            <div id="editColorPalette" style="display:flex; gap:5px; flex-wrap:wrap; margin-bottom:10px;"></div>
            <input type="hidden" id="edit-color" oninput="updateNode()">
            <label>Opacité <span id="opacity-val" style="float:right">100%</span></label>
            <input type="range" id="edit-opacity" min="0" max="100" value="100" oninput="updateNode()">
            <label>Taille (px)</label>
            <input type="number" id="edit-size" min="20" max="300" oninput="updateNode()" style="width:100%; padding:5px; background:var(--bg-dark); border:1px solid var(--border-color); color:#fff; border-radius:4px;">
            
            <div id="docker-controls" style="display:none; margin-top:15px;">
                <div class="section-header" style="margin-top:0">Contrôles Docker</div>
                <div id="docker-status" style="padding:10px; background:rgba(0,0,0,0.3); border-radius:6px; margin-bottom:10px;">
                    <div style="display:flex; align-items:center; gap:8px;">
                        <span id="docker-status-indicator" style="width:12px; height:12px; border-radius:50%; background:#94a3b8;"></span>
                        <span id="docker-status-text" style="font-size:12px; color:var(--text-secondary);">Non connecté</span>
                    </div>
                </div>
                <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:5px;">
                    <button class="btn-ghost" onclick="dockerAction('start')" style="font-size:10px; padding:6px;">
                        <i class="fas fa-play"></i>
                    </button>
                    <button class="btn-ghost" onclick="dockerAction('stop')" style="font-size:10px; padding:6px;">
                        <i class="fas fa-stop"></i>
                    </button>
                    <button class="btn-ghost" onclick="dockerAction('restart')" style="font-size:10px; padding:6px;">
                        <i class="fas fa-redo"></i>
                    </button>
                </div>
                <button class="btn-ghost" onclick="refreshDockerStatus()" style="width:100%; margin-top:5px; font-size:11px;">
                    <i class="fas fa-sync"></i> Rafraîchir
                </button>
            </div>
        </div>

        <div id="insp-content-edge" style="display:none;">
            <div class="section-header" style="margin-top:0">Modifier Câble</div>
            <label>Style</label>
            <select id="edit-edge-type" onchange="updateEdge()">
                <option value="solid">Solide</option>
                <option value="dashed">Pointillés</option>
            </select>
            <label>Couleur</label>
            <input type="color" id="edit-edge-color" style="height:35px; padding:0;" oninput="updateEdge()">
            <label>Épaisseur</label>
            <input type="range" id="edit-edge-width" min="1" max="10" oninput="updateEdge()">
        </div>

        <div style="margin-top:20px; display:flex; gap:10px;">
            <button class="btn-danger" style="flex:1;" onclick="deleteSelected()"><i class="fas fa-trash"></i></button>
            <button class="btn-ghost" style="flex:1;" onclick="closeInspector()">Fermer</button>
        </div>
    </div>
    
    <!-- Minimap -->
    <div id="minimap">
        <div id="minimap-header">Vue d'ensemble</div>
        <canvas id="minimap-canvas"></canvas>
    </div>
    
    <!-- Legend -->
    <div id="legend">
        <div id="legend-header" onclick="toggleLegend()">
            <h3><i class="fas fa-list"></i> Légende</h3>
            <i class="fas fa-chevron-up" id="legend-toggle-icon"></i>
        </div>
        <div id="legend-content"></div>
    </div>
    
    <!-- Statistics -->
    <div id="statistics">
        <h3><i class="fas fa-chart-bar"></i> Statistiques</h3>
        <div class="stat-item">
            <span class="stat-label">Nœuds</span>
            <span class="stat-value" id="stat-nodes">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Connexions</span>
            <span class="stat-value" id="stat-edges">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Docker Running</span>
            <span class="stat-value" id="stat-docker-running">0</span>
        </div>
        <div class="stat-item">
            <span class="stat-label">Docker Stopped</span>
            <span class="stat-value" id="stat-docker-stopped">0</span>
        </div>
    </div>
    
    <!-- Navigation Controls -->
    <div id="nav-controls">
        <button onclick="network.moveTo({scale: network.getScale() * 1.2})" title="Zoom In">
            <i class="fas fa-plus"></i>
        </button>
        <button onclick="network.moveTo({scale: network.getScale() * 0.8})" title="Zoom Out">
            <i class="fas fa-minus"></i>
        </button>
        <button onclick="network.fit()" title="Fit to Screen">
            <i class="fas fa-expand"></i>
        </button>
    </div>

    <script>
        // CONFIG
        const icons = {
            server: {code:'\uf233', fa:'fa-solid fa-server'},
            router: {code:'\uf0ec', fa:'fa-solid fa-network-wired'},
            switch: {code:'\uf2db', fa:'fa-solid fa-microchip'},
            firewall: {code:'\uf132', fa:'fa-solid fa-shield-halved'},
            cloud: {code:'\uf0c2', fa:'fa-solid fa-cloud'},
            db: {code:'\uf1c0', fa:'fa-solid fa-database'},
            pc: {code:'\uf108', fa:'fa-solid fa-desktop'},
            printer: {code:'\uf02f', fa:'fa-solid fa-print'},
            wifi: {code:'\uf1eb', fa:'fa-solid fa-wifi'},
            note: {code:'\uf249', fa:'fa-solid fa-sticky-note'},
            docker: {code:'\uf395', fa:'fa-brands fa-docker'}
        };

        let nodes = new vis.DataSet([]);
        let edges = new vis.DataSet([]);
        let network = null;
        let selectedNodeId = null;
        let selectedEdgeId = null;
        let customImgBase64 = null;
        let magnetMode = false;
        let linkMode = false;
        const colors = ['#ef4444', '#f97316', '#f59e0b', '#84cc16', '#10b981', '#06b6d4', '#38bdf8', '#6366f1', '#8b5cf6', '#d946ef', '#f43f5e', '#ffffff', '#94a3b8', '#475569', '#0f172a'];
        const DOCKER_BLUE = '#2496ED';
        
        // Helper function to escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Helper function to get status color
        function getStatusColor(state) {
            const stateLower = state.toLowerCase();
            if(stateLower === 'running') return '#4ade80';
            if(stateLower === 'paused' || stateLower === 'restarting') return '#fbbf24';
            if(stateLower === 'stopped' || stateLower === 'exited') return '#f87171';
            return '#94a3b8';
        }
        
        const planId = "<%= plan.id %>";
        // Use a safe way to inject JSON
        const rawPlanData = <%- plan.data ? JSON.stringify(plan.data) : 'null' %>;

        window.onload = function() {
            // --- COLOR PALETTE ---
            const palette = document.getElementById('colorPalette');
            const nodeColorInput = document.getElementById('nodeColor');
            
            if(palette) {
                colors.forEach(c => {
                    const div = document.createElement('div');
                    div.style.cssText = `width:20px; height:20px; background:${c}; border-radius:3px; cursor:pointer; border:1px solid #334155;`;
                    div.onclick = () => {
                        nodeColorInput.value = c;
                        Array.from(palette.children).forEach(ch => ch.style.borderColor = '#334155');
                        div.style.borderColor = '#fff';
                    };
                    palette.appendChild(div);
                });
                // Select default (Sky Blue)
                if(palette.children[6]) palette.children[6].click();
            }

            // Load from DB
            if(rawPlanData) {
                try {
                    let parsed = rawPlanData;
                    if (typeof rawPlanData === 'string') {
                        parsed = JSON.parse(rawPlanData);
                    }
                    if (parsed.nodes) nodes.add(parsed.nodes);
                    if (parsed.edges) edges.add(parsed.edges);
                    updateSelects(); 
                } catch(e) {
                    console.error("Error loading plan data", e);
                }
            }

            const container = document.getElementById('network-container');
            const data = { nodes, edges };
            const options = {
                nodes: {
                    shape: 'icon',
                    icon: { face: "'Font Awesome 6 Free'", weight: "900", size: 45, color: '#fff' },
                    font: { face: 'Inter', color: '#fff', size: 14, strokeWidth: 4, strokeColor: '#0f172a', multi: 'html', vadjust: 4 },
                    shadow: { enabled: true, color: 'rgba(0,0,0,0.5)' }
                },
                edges: {
                    width: 2,
                    color: { color: '#64748b', highlight: '#38bdf8' },
                    smooth: { type: 'continuous', roundness: 0.2 }
                },
                physics: { enabled: false },
                interaction: { hover: true, multiselect: true, navigationButtons: false, dragView: false },
                manipulation: {
                    enabled: true,
                    initiallyActive: false,
                    addNode: false,
                    addEdge: function(data, callback) {
                        if (data.from !== data.to) {
                            callback(data);
                            savePlan(false);
                        } else {
                            callback(null);
                        }
                        // Re-enable mode if active
                        if(linkMode) setTimeout(() => network.addEdgeMode(), 50);
                    },
                    editEdge: false,
                    deleteNode: false,
                    deleteEdge: false,
                    controlNodeStyle: {
                        shape: 'dot',
                        size: 6,
                        color: { background: '#38bdf8', border: '#0f172a' },
                        borderWidth: 2
                    }
                }
            };

            network = new vis.Network(container, data, options);

            // --- CUSTOM INTERACTION (Right Click Pan / Left Click Select / Resize) ---
            const selectionBox = document.getElementById('selectionBox');
            let isSelecting = false;
            let isPanning = false;
            let isResizing = false;
            let resizeNodeId = null;
            let resizeStartSize = 0;
            let resizeStartPos = {x:0, y:0};
            let startPos = {x:0, y:0};
            let lastPos = {x:0, y:0};

            function getCanvasPos(e) {
                const canvas = container.querySelector('canvas');
                if (canvas) {
                    const rect = canvas.getBoundingClientRect();
                    return {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                }
                const rect = container.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            // Use capture to intercept events before Vis.js
            container.addEventListener('mousedown', function(e) {
                const containerRect = container.getBoundingClientRect();
                const mouseX = e.clientX - containerRect.left;
                const mouseY = e.clientY - containerRect.top;
                
                // 1. Check Resize Handles (Using DOM Coordinates for accuracy)
                try {
                    const selected = network.getSelectedNodes();
                    
                    for (const id of selected) {
                        const handles = getNodeHandles(id); // Canvas Coords
                        for (const h in handles) {
                            const handleCanvasPos = handles[h];
                            const handleDOMPos = network.canvasToDOM(handleCanvasPos); // DOM Coords
                            
                            // Calculate distance in screen pixels
                            const dist = Math.sqrt((mouseX - handleDOMPos.x)**2 + (mouseY - handleDOMPos.y)**2);
                            
                            if (dist < 20) { // 20px screen hit radius
                                 isResizing = true;
                                 resizeNodeId = id;
                                 resizeHandle = h;
                                 const node = nodes.get(id);
                                 
                                 // Robust size retrieval
                                 let currentSize = 45; 
                                 if (node.shape === 'box' && node.font && node.font.size) currentSize = node.font.size;
                                 else if (node.shape === 'image' && node.size) currentSize = node.size;
                                 else if (node.icon && node.icon.size) currentSize = node.icon.size;
                                 else if (node.size) currentSize = node.size;
                                 
                                 resizeStartSize = currentSize;
                                 resizeStartPos = {x: e.clientX, y: e.clientY};
                                 
                                 e.stopPropagation(); 
                                 e.preventDefault();
                                 return; 
                            }
                        }
                    }
                } catch(err) { console.log("Resize check error", err); }

                // 2. Check Node/Edge Hit
                // We use DOMToCanvas for getNodeAt because it expects canvas coords? 
                // No, getNodeAt expects DOM coordinates (pixel coordinates relative to canvas)
                const pointer = {x: mouseX, y: mouseY}; 
                const node = network.getNodeAt(pointer);
                const edge = network.getEdgeAt(pointer);
                
                if (node !== undefined || edge !== undefined || linkMode) {
                    return;
                }

                // 3. Selection Box or Pan
                if (e.button === 0) { // Left Click -> Selection Box
                    isSelecting = true;
                    startPos = {x: mouseX, y: mouseY};
                    
                    selectionBox.style.left = startPos.x + 'px';
                    selectionBox.style.top = startPos.y + 'px';
                    selectionBox.style.width = '0px';
                    selectionBox.style.height = '0px';
                    selectionBox.style.display = 'block';
                    e.stopPropagation();
                    e.preventDefault();
                } else if (e.button === 2) { // Right Click -> Pan
                    isPanning = true;
                    lastPos = {x: e.clientX, y: e.clientY};
                    container.style.cursor = 'grabbing';
                    e.stopPropagation();
                    e.preventDefault();
                }
            }, true);

            window.addEventListener('mousemove', function(e) {
                if (isResizing) {
                    const dx = e.clientX - resizeStartPos.x;
                    const dy = e.clientY - resizeStartPos.y;
                    
                    let delta = 0;
                    // Adjust sensitivity: 1 screen pixel = 0.5 size unit
                    const sensitivity = 0.5;
                    
                    if (resizeHandle === 'br') delta = (dx + dy) / 2;
                    else if (resizeHandle === 'tl') delta = -(dx + dy) / 2;
                    else if (resizeHandle === 'tr') delta = (dx - dy) / 2;
                    else if (resizeHandle === 'bl') delta = (-dx + dy) / 2;
                    
                    let newSize = resizeStartSize + (delta * sensitivity);
                    if (newSize < 10) newSize = 10;
                    if (newSize > 300) newSize = 300;

                    const node = nodes.get(resizeNodeId);
                    if(!node) return;

                    const d = node._data || {};
                    let updateObj = { id: resizeNodeId, _data: {...d, size: newSize} };
                    
                    if(node.shape === 'box') {
                        updateObj.font = { ...(node.font || {}), size: newSize };
                    } else {
                        if(node.shape === 'image') updateObj.size = newSize;
                        else updateObj.icon = { ...(node.icon || {}), size: newSize };
                    }
                    nodes.update(updateObj);
                    
                    // Update inspector if open
                    if(selectedNodeId === resizeNodeId) {
                        const input = document.getElementById('edit-size');
                        if(input) input.value = Math.round(newSize);
                    }
                    e.preventDefault();

                } else if (isSelecting) {
                    const containerRect = container.getBoundingClientRect();
                    const currentX = e.clientX - containerRect.left;
                    const currentY = e.clientY - containerRect.top;
                    
                    const x = Math.min(startPos.x, currentX);
                    const y = Math.min(startPos.y, currentY);
                    const w = Math.abs(currentX - startPos.x);
                    const h = Math.abs(currentY - startPos.y);
                    
                    selectionBox.style.left = x + 'px';
                    selectionBox.style.top = y + 'px';
                    selectionBox.style.width = w + 'px';
                    selectionBox.style.height = h + 'px';
                } else if (isPanning) {
                    const dx = e.clientX - lastPos.x;
                    const dy = e.clientY - lastPos.y;
                    lastPos = {x: e.clientX, y: e.clientY};
                    
                    const translation = network.body.view.translation;
                    network.body.view.translation = {
                        x: translation.x + dx,
                        y: translation.y + dy
                    };
                    network.redraw(); 
                } else {
                    // Cursor update for handles
                    const containerRect = container.getBoundingClientRect();
                    const mouseX = e.clientX - containerRect.left;
                    const mouseY = e.clientY - containerRect.top;
                    
                    let overHandle = false;
                    try {
                        const selected = network.getSelectedNodes();
                        for (const id of selected) {
                            const handles = getNodeHandles(id);
                            for (const h in handles) {
                                const handleCanvasPos = handles[h];
                                const handleDOMPos = network.canvasToDOM(handleCanvasPos);
                                const dist = Math.sqrt((mouseX - handleDOMPos.x)**2 + (mouseY - handleDOMPos.y)**2);
                                
                                if (dist < 20) {
                                    overHandle = true;
                                    if (h === 'tl' || h === 'br') container.style.cursor = 'nwse-resize';
                                    else container.style.cursor = 'nesw-resize';
                                    break;
                                }
                            }
                            if(overHandle) break;
                        }
                    } catch(e) {}
                    
                    if(!overHandle && !linkMode && !isPanning) container.style.cursor = 'default';
                }
            });

            window.addEventListener('mouseup', function(e) {
                if (isResizing) {
                    isResizing = false;
                    savePlan(false);
                } else if (isSelecting) {
                    isSelecting = false;
                    
                    // Calculate selected nodes BEFORE hiding box
                    const rect = selectionBox.getBoundingClientRect();
                    const containerRect = container.getBoundingClientRect();
                    
                    selectionBox.style.display = 'none';

                    // Selection area relative to container (DOM coords)
                    const selectRect = {
                        left: rect.left - containerRect.left,
                        top: rect.top - containerRect.top,
                        right: rect.right - containerRect.left,
                        bottom: rect.bottom - containerRect.top
                    };
                    
                    // Select nodes inside
                    const allNodes = nodes.get();
                    const selectedIds = [];
                    allNodes.forEach(n => {
                        const pos = network.getPositions([n.id])[n.id]; // Canvas coords
                        if (!pos) return;
                        const domPos = network.canvasToDOM(pos); // DOM coords
                        
                        if (domPos.x >= selectRect.left && domPos.x <= selectRect.right &&
                            domPos.y >= selectRect.top && domPos.y <= selectRect.bottom) {
                            selectedIds.push(n.id);
                        }
                    });
                    
                    if (e.ctrlKey) {
                        const current = network.getSelectedNodes();
                        network.selectNodes([...new Set([...current, ...selectedIds])]);
                    } else {
                        network.selectNodes(selectedIds);
                    }
                    
                } else if (isPanning) {
                    isPanning = false;
                    container.style.cursor = 'default';
                }
            });

            container.addEventListener('contextmenu', e => e.preventDefault());

            // Limit Zoom
            network.on("zoom", function (params) {
                if (params.scale < 0.2) {
                    network.moveTo({ scale: 0.2, animation: false });
                }
                if (params.scale > 4.0) {
                    network.moveTo({ scale: 4.0, animation: false });
                }
            });

            // Initial draw
            network.once("afterDrawing", function() {
                const scale = network.getScale();
                const translation = network.body.view.translation;
                drawRulers(scale, translation);
            });

            // Sync grid with network movement
            network.on("afterDrawing", function (ctx) {
                const container = document.getElementById('network-container');
                const scale = network.getScale();
                const translation = network.body.view.translation;

                if (container.classList.contains('grid-bg')) {
                    if (scale < 0.2) {
                        container.style.backgroundImage = 'none';
                    } else {
                        container.style.backgroundImage = ''; // Restore CSS default
                        const gridSize = 40 * scale;
                        container.style.backgroundSize = `${gridSize}px ${gridSize}px`;
                        container.style.backgroundPosition = `${translation.x}px ${translation.y}px`;
                    }
                } else {
                    container.style.backgroundPosition = '';
                    container.style.backgroundSize = '';
                    container.style.backgroundImage = '';
                }
                
                drawRulers(scale, translation);
                drawSelectionHandles(ctx);
            });

            function drawSelectionHandles(ctx) {
                const selected = network.getSelectedNodes();
                if (selected.length === 0) return;

                selected.forEach(id => {
                    const bb = network.getBoundingBox(id);
                    // Add padding
                    const p = 5;
                    const left = bb.left - p;
                    const top = bb.top - p;
                    const width = (bb.right - bb.left) + 2*p;
                    const height = (bb.bottom - bb.top) + 2*p;

                    // Draw box
                    ctx.beginPath();
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = '#38bdf8';
                    ctx.setLineDash([5, 5]);
                    ctx.rect(left, top, width, height);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw handles
                    ctx.fillStyle = '#38bdf8';
                    const handles = getNodeHandles(id);
                    for (const h in handles) {
                        const pt = handles[h];
                        ctx.beginPath();
                        ctx.arc(pt.x, pt.y, 4, 0, 2*Math.PI);
                        ctx.fill();
                    }
                });
            }

            function getNodeHandles(nodeId) {
                const bb = network.getBoundingBox(nodeId);
                const p = 5;
                return {
                    tl: {x: bb.left - p, y: bb.top - p},
                    tr: {x: bb.right + p, y: bb.top - p},
                    bl: {x: bb.left - p, y: bb.bottom + p},
                    br: {x: bb.right + p, y: bb.bottom + p}
                };
            }

            /*
            // Custom Drawing for Anchor Points
            network.on("afterDrawing", function (ctx) {
                const selected = network.getSelectedNodes();
                if(selected.length === 0) return;

                const positions = network.getPositions(selected);
                
                selected.forEach(id => {
                    const pos = positions[id];
                    if(!pos) return;
                    
                    // Draw 4 anchor points
                    const r = 35; // Distance from center
                    const anchors = [
                        {x: pos.x, y: pos.y - r}, // Top
                        {x: pos.x, y: pos.y + r}, // Bottom
                        {x: pos.x - r, y: pos.y}, // Left
                        {x: pos.x + r, y: pos.y}  // Right
                    ];

                    ctx.strokeStyle = '#38bdf8';
                    ctx.fillStyle = '#38bdf8';
                    ctx.lineWidth = 1;

                    anchors.forEach(p => {
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, 3, 0, 2*Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    });
                });
            });
            */

            // Events
            network.on("click", function (params) {
                if (params.nodes.length > 0) openNodeInspector(params.nodes[0]);
                else if (params.edges.length > 0) openEdgeInspector(params.edges[0]);
                else closeInspector();
            });

            network.on("dragEnd", function(params) {
                if(magnetMode && params.nodes.length > 0) {
                    snapToGrid(params.nodes);
                }
                savePlan(false);
                updateMinimap();
            });
            
            // Update UI on changes
            nodes.on('*', function() {
                updateStatistics();
                updateLegend();
                updateMinimap();
            });
            
            edges.on('*', function() {
                updateStatistics();
                updateMinimap();
            });
            
            network.on('zoom', function() {
                updateMinimap();
            });
            
            network.on('dragStart', function() {
                updateMinimap();
            });

            // Auto-save every 30s
            setInterval(() => savePlan(false), 30000);

            document.getElementById('customImg').addEventListener('change', e => {
                const f = e.target.files[0];
                if(f) { 
                    const r = new FileReader(); 
                    r.onload = ev => {
                        const imgBase64 = ev.target.result;
                        const label = document.getElementById('nodeLabel').value || "Image";
                        const node = {
                            id: Date.now(),
                            label: `<b>${label}</b>`,
                            shape: 'image',
                            image: imgBase64,
                            size: 50,
                            _data: { name: label, ip: "", type: 'custom', color: '#ffffff', size: 50, opacity: 100, isCustom: true, img: imgBase64 }
                        };
                        nodes.add(node);
                        updateSelects(); savePlan(false);
                        document.getElementById('nodeLabel').value="";
                    }; 
                    r.readAsDataURL(f); 
                }
            });

            document.addEventListener('keydown', e => { if(e.key==="Delete") deleteSelected(); });

            // Drag Drop
            const dz = document.getElementById('dropZone');
            document.body.addEventListener('dragover', e => { e.preventDefault(); dz.style.display='flex'; });
            dz.addEventListener('dragleave', e => { e.preventDefault(); dz.style.display='none'; });
            dz.addEventListener('drop', e => {
                e.preventDefault(); dz.style.display='none';
                const file = e.dataTransfer.files[0];
                if(file && file.name.endsWith('.json')) loadFile(file);
            });
            
            // Initialize UI components
            updateStatistics();
            updateLegend();
            setTimeout(updateMinimap, 500);
        };

        // --- ALIGNMENT TOOLS ---
        function toggleMagnet() {
            magnetMode = !magnetMode;
            const btn = document.getElementById('btnMagnet');
            if(magnetMode) btn.classList.add('active');
            else btn.classList.remove('active');
        }

        function toggleLinkMode() {
            linkMode = !linkMode;
            const btn = document.getElementById('btnLinkMode');
            const container = document.getElementById('network-container');
            
            if(linkMode) {
                btn.classList.add('active');
                container.style.cursor = 'crosshair';
                network.addEdgeMode();
            } else {
                btn.classList.remove('active');
                container.style.cursor = 'default';
                network.disableEditMode();
            }
        }

        function snapToGrid(nodeIds) {
            const gridSize = 40;
            const positions = network.getPositions(nodeIds);
            const updates = [];
            nodeIds.forEach(id => {
                let x = Math.round(positions[id].x / gridSize) * gridSize;
                let y = Math.round(positions[id].y / gridSize) * gridSize;
                updates.push({id: id, x: x, y: y});
            });
            nodes.update(updates);
        }

        function alignNodes(direction) {
            const selected = network.getSelectedNodes();
            if(selected.length < 2) return alert("Sélectionnez au moins 2 noeuds.");
            
            const positions = network.getPositions(selected);
            let targetVal = 0;

            if(direction === 'UD') { // Vertical Alignment (same X)
                let sumX = 0;
                selected.forEach(id => sumX += positions[id].x);
                targetVal = sumX / selected.length;
                const updates = selected.map(id => ({id: id, x: targetVal}));
                nodes.update(updates);
            } else { // Horizontal Alignment (same Y)
                let sumY = 0;
                selected.forEach(id => sumY += positions[id].y);
                targetVal = sumY / selected.length;
                const updates = selected.map(id => ({id: id, y: targetVal}));
                nodes.update(updates);
            }
            savePlan(false);
        }

        // --- DRAW.IO EXPORT LOGIC ---
        function exportDrawIO() {
            const allNodes = nodes.get();
            const allEdges = edges.get();
            const positions = network.getPositions(allNodes.map(n => n.id));

            let xml = '<?xml version="1.0" encoding="UTF-8"?>';
            xml += '<mxGraphModel dx="1000" dy="1000" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="827" pageHeight="1169" math="0" shadow="0">';
            xml += '<root><mxCell id="0"/><mxCell id="1" parent="0"/>';

            allNodes.forEach(n => {
                const pos = positions[n.id];
                // Conversion couleur Hex
                let color = n.color ? (n.color.background || n.color) : '#ffffff';
                let label = n._data.name;
                
                // Style Drawio
                let style = "";
                if(n.shape === 'image' && n._data.img) {
                    // Embed image base64
                    style = `shape=image;verticalLabelPosition=bottom;verticalAlign=top;imageAspect=0;image=${n._data.img};`;
                } else if (n.shape === 'box') {
                    style = `shape=rectangle;whiteSpace=wrap;html=1;fillColor=${color};strokeColor=${n.color.border||color};opacity=${n._data.opacity||100};`;
                } else {
                    // Standard shape for icons (rectangle arrondi)
                    style = `rounded=1;whiteSpace=wrap;html=1;fillColor=${color};strokeColor=none;fontColor=#ffffff;`;
                }

                xml += `<mxCell id="${n.id}" value="${label}" style="${style}" vertex="1" parent="1">`;
                xml += `<mxGeometry x="${pos.x}" y="${pos.y}" width="${n.size}" height="${n.size}" as="geometry"/>`;
                xml += `</mxCell>`;
            });

            allEdges.forEach(e => {
                let color = e.color ? (e.color.color || e.color) : '#000000';
                let style = `edgeStyle=orthogonalEdgeStyle;rounded=0;orthogonalLoop=1;jettySize=auto;html=1;strokeColor=${color};strokeWidth=${e.width};`;
                if(e.dashes) style += "dashed=1;";

                xml += `<mxCell id="edge_${e.id}" edge="1" parent="1" source="${e.from}" target="${e.to}" style="${style}">`;
                xml += `<mxGeometry relative="1" as="geometry"/></mxCell>`;
            });

            xml += '</root></mxGraphModel>';

            downloadFile(xml, 'nexus_export.xml', 'application/xml');
        }

        // --- STANDARD FUNCTIONS ---
        function addNode(type) {
            const labelInput = document.getElementById('nodeLabel').value;
            const label = labelInput || (type === 'note' ? "Note" : type.charAt(0).toUpperCase() + type.slice(1));
            const ip = document.getElementById('nodeIP').value;
            // Use Docker blue for docker type, otherwise use selected color
            const color = type === 'docker' ? DOCKER_BLUE : document.getElementById('nodeColor').value;

            let node = {
                id: Date.now(),
                label: `\n<b>${label}</b>` + (ip ? `\n${ip}` : ""),
                _data: { name: label, ip: ip, type: type, color: color, size: 45, opacity: 100 }
            };

            if(type === 'note') {
                node.shape = 'box';
                node.color = { background: color, border: color };
                node.font = { color: '#000', size: 16, strokeWidth: 0, multi:false };
                node.label = label;
                node.shapeProperties = { borderDashes: false };
            } else {
                const def = icons[type] || icons.server;
                // Use correct font face for brands vs solid icons
                const fontFace = type === 'docker' ? "'Font Awesome 6 Brands'" : "'Font Awesome 6 Free'";
                node.icon = { code: def.code, color: color, face: fontFace };
                node._data.fa = def.fa;
            }

            nodes.add(node);
            updateSelects(); savePlan(false);
            document.getElementById('nodeLabel').value=""; document.getElementById('nodeIP').value="";
        }

        function connectSelectedNodes() {
            const selection = network.getSelectedNodes();
            if(selection.length !== 2) return alert("Sélectionnez 2 noeuds (Ctrl+Clic).");
            edges.add({ from: selection[0], to: selection[1] });
            savePlan(false); showToast("Lien créé");
        }

        function addEdge() {
            const f = document.getElementById('fromNode').value;
            const t = document.getElementById('toNode').value;
            if(f && t && f!==t) { edges.add({ from: f, to: t }); savePlan(false); }
        }

        function openNodeInspector(id) {
            selectedNodeId = id; selectedEdgeId = null;
            const node = nodes.get(id);
            const d = node._data || {};
            document.getElementById('inspector').style.display = 'block';
            document.getElementById('insp-content-node').style.display = 'block';
            document.getElementById('insp-content-edge').style.display = 'none';

            document.getElementById('edit-name').value = d.name || "";
            document.getElementById('edit-ip').value = d.ip || "";
            document.getElementById('edit-color').value = d.color || "#ffffff";

            // Palette Inspector
            const palette = document.getElementById('editColorPalette');
            if(palette) {
                palette.innerHTML = '';
                colors.forEach(c => {
                    const div = document.createElement('div');
                    div.style.cssText = `width:20px; height:20px; background:${c}; border-radius:3px; cursor:pointer; border:1px solid #334155;`;
                    if(c === (d.color || "#ffffff")) div.style.borderColor = '#fff';
                    div.onclick = () => {
                        document.getElementById('edit-color').value = c;
                        updateNode();
                        Array.from(palette.children).forEach(ch => ch.style.borderColor = '#334155');
                        div.style.borderColor = '#fff';
                    };
                    palette.appendChild(div);
                });
            }

            let op = d.opacity !== undefined ? d.opacity : 100;
            document.getElementById('edit-opacity').value = op;
            document.getElementById('opacity-val').innerText = op + "%";
            let s = node.size || (node.icon ? node.icon.size : 40);
            if(node.font && node.shape === 'box') s = node.font.size;
            document.getElementById('edit-size').value = s;
            
            // Show Docker controls if it's a Docker node
            const dockerControls = document.getElementById('docker-controls');
            if(d.type === 'docker') {
                dockerControls.style.display = 'block';
                if(d.dockerId) {
                    refreshDockerStatus();
                } else {
                    document.getElementById('docker-status-text').innerText = 'Container non lié';
                }
            } else {
                dockerControls.style.display = 'none';
            }
        }

        function updateNode() {
            if(!selectedNodeId) return;
            const name = document.getElementById('edit-name').value;
            const ip = document.getElementById('edit-ip').value;
            const color = document.getElementById('edit-color').value;
            const size = parseInt(document.getElementById('edit-size').value);
            const opacity = parseInt(document.getElementById('edit-opacity').value);
            document.getElementById('opacity-val').innerText = opacity + "%";

            const node = nodes.get(selectedNodeId);
            const d = node._data || {};
            let updateObj = { id: selectedNodeId, _data: {...d, name, ip, color, size, opacity} };
            
            function hexToRgba(hex, alpha) {
                let r = parseInt(hex.slice(1, 3), 16), g = parseInt(hex.slice(3, 5), 16), b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            const alpha = opacity / 100;

            if(node.shape === 'box') {
                updateObj.label = name;
                updateObj.color = { background: hexToRgba(color, alpha), border: color };
                updateObj.font = { ...node.font, size: size };
            } else {
                updateObj.label = `\n<b>${name}</b>` + (ip ? `\n${ip}` : "");
                if(node.shape === 'image') updateObj.size = size;
                else updateObj.icon = { ...node.icon, color: hexToRgba(color, alpha), size: size };
            }
            nodes.update(updateObj);
            savePlan(false);
        }

        function openEdgeInspector(id) {
            selectedEdgeId = id; selectedNodeId = null;
            const edge = edges.get(id);
            document.getElementById('inspector').style.display='block';
            document.getElementById('insp-content-node').style.display='none';
            document.getElementById('insp-content-edge').style.display='block';
            document.getElementById('edit-edge-color').value = edge.color ? (edge.color.color||edge.color) : '#64748b';
            document.getElementById('edit-edge-width').value = edge.width || 2;
        }

        function updateEdge() {
            if(!selectedEdgeId) return;
            const c = document.getElementById('edit-edge-color').value;
            const w = parseInt(document.getElementById('edit-edge-width').value);
            const t = document.getElementById('edit-edge-type').value;
            edges.update({ id: selectedEdgeId, color:{color:c, highlight:c}, width:w, dashes: t==='dashed' });
            savePlan(false);
        }

        function deleteSelected() {
            if(selectedNodeId) { nodes.remove(selectedNodeId); updateSelects(); }
            if(selectedEdgeId) edges.remove(selectedEdgeId);
            closeInspector(); savePlan(false);
        }

        function closeInspector() { document.getElementById('inspector').style.display='none'; selectedNodeId=null; selectedEdgeId=null; network.unselectAll(); }
        
        function savePlan(notif) { 
            const data = { nodes: nodes.get(), edges: edges.get() };
            fetch('/api/save/' + planId, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ data: data })
            })
            .then(res => res.json())
            .then(res => {
                if (res.success) {
                    if (notif) showToast("Sauvegardé sur le serveur");
                } else {
                    showToast("Erreur de sauvegarde");
                }
            })
            .catch(err => showToast("Erreur réseau"));
        }

        function triggerLoad() { document.getElementById('fileLoader').click(); }
        function loadJSONFromFile(input) { loadFile(input.files[0]); }
        function loadFile(file) {
            if(!file) return; const r = new FileReader();
            r.onload = e => { try { const d = JSON.parse(e.target.result); nodes.clear(); edges.clear(); nodes.add(d.nodes); edges.add(d.edges); updateSelects(); showToast("Ouvert"); savePlan(false); } catch(err) { alert("Invalide"); } };
            r.readAsText(file);
        }
        function toggleFullscreen() { if(!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); }
        function toggleGrid() { 
            document.getElementById('network-container').classList.toggle('grid-bg'); 
            network.redraw();
        }
        function updateSelects() {
            const s1=document.getElementById('fromNode'), s2=document.getElementById('toNode');
            s1.innerHTML='<option>De...</option>'; s2.innerHTML='<option>Vers...</option>';
            nodes.get().forEach(n=>{ let op=`<option value="${n.id}">${n._data?n._data.name:n.label}</option>`; s1.innerHTML+=op; s2.innerHTML+=op; });
        }
        function showToast(m) { const t=document.getElementById('toast'); t.innerHTML=m; t.style.opacity=1; t.style.bottom="40px"; setTimeout(()=>{t.style.opacity=0;t.style.bottom="30px";},2000); }
        function searchNetwork() {
            const term = document.getElementById('searchNode').value.toLowerCase();
            if(term.length<2) return;
            const found = nodes.get().find(n=>(n._data&&n._data.name.toLowerCase().includes(term))||(n.label&&n.label.toLowerCase().includes(term)));
            if(found) { network.selectNodes([found.id]); network.focus(found.id,{scale:1.5,animation:true}); openNodeInspector(found.id); }
        }
        function exportJSON() { const d = {nodes:nodes.get(), edges:edges.get()}; const b = new Blob([JSON.stringify(d)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='nexus.json'; a.click(); }
        function exportPDF() { network.fit({animation:false}); setTimeout(()=>{ const cvs = document.querySelector('canvas'); const pdf = new window.jspdf.jsPDF('l','mm','a4'); pdf.addImage(cvs.toDataURL("image/jpeg",1.0),'JPEG',10,10,280,150); pdf.save("schema.pdf"); },500); }
        function downloadFile(content, name, type) { const blob = new Blob([content], {type}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name; a.click(); }

        function drawRulers(scale, translation) {
            const topCanvas = document.getElementById('ruler-top');
            const leftCanvas = document.getElementById('ruler-left');
            const container = document.getElementById('network-container');
            
            if(!topCanvas || !leftCanvas) return;

            if(topCanvas.width !== container.offsetWidth) topCanvas.width = container.offsetWidth;
            if(topCanvas.height !== 20) topCanvas.height = 20;
            if(leftCanvas.width !== 20) leftCanvas.width = 20;
            if(leftCanvas.height !== container.offsetHeight) leftCanvas.height = container.offsetHeight;

            const ctxT = topCanvas.getContext('2d');
            const ctxL = leftCanvas.getContext('2d');

            ctxT.clearRect(0, 0, topCanvas.width, topCanvas.height);
            ctxL.clearRect(0, 0, leftCanvas.width, leftCanvas.height);

            ctxT.fillStyle = '#94a3b8';
            ctxL.fillStyle = '#94a3b8';
            ctxT.font = '10px Inter';
            ctxL.font = '10px Inter';
            
            let step = 100;
            if (scale > 2) step = 20;
            else if (scale > 0.8) step = 50;
            else if (scale > 0.4) step = 100;
            else step = 200;

            const startX = -translation.x / scale;
            const startY = -translation.y / scale;
            
            const firstX = Math.floor(startX / step) * step;
            const firstY = Math.floor(startY / step) * step;

            for (let x = firstX; ; x += step) {
                const screenX = x * scale + translation.x;
                if (screenX > topCanvas.width) break;
                if (screenX < 20) continue; 

                ctxT.beginPath();
                ctxT.moveTo(screenX, 15);
                ctxT.lineTo(screenX, 20);
                ctxT.strokeStyle = '#64748b';
                ctxT.stroke();
                ctxT.fillText(x, screenX + 2, 12);
            }

            for (let y = firstY; ; y += step) {
                const screenY = y * scale + translation.y;
                if (screenY > leftCanvas.height) break;
                if (screenY < 20) continue;

                ctxL.beginPath();
                ctxL.moveTo(15, screenY);
                ctxL.lineTo(20, screenY);
                ctxL.strokeStyle = '#64748b';
                ctxL.stroke();

                ctxL.save();
                ctxL.translate(12, screenY + 2);
                ctxL.rotate(-Math.PI / 2);
                ctxL.fillText(y, 0, 0);
                ctxL.restore();
            }
            
            ctxT.fillStyle = '#1e293b';
            ctxT.fillRect(0,0,20,20);
            ctxL.fillStyle = '#1e293b';
            ctxL.fillRect(0,0,20,20);
        }
        
        // --- DOCKER FUNCTIONS ---
        async function generateDockerSchema() {
            if(!confirm("Cela va ajouter tous vos containers et tenter de les relier au réseau. Continuer ?")) return;
            
            try {
                // 1. Fetch Containers
                const response = await fetch('/api/docker/containers');
                const result = await response.json();
                
                if(!result.success) {
                    showToast('Impossible de récupérer les containers');
                    return;
                }
                
                const containers = result.containers;
                if(containers.length === 0) {
                    showToast('Aucun container trouvé');
                    return;
                }

                // 2. Fetch Networks (We need this to know who is connected to whom)
                // Note: We need to implement this endpoint or just rely on container info if simpler
                const netResponse = await fetch('/api/docker/networks');
                const netResult = await netResponse.json();
                const networksMap = {}; // NetworkName -> [ContainerIds]
                
                if(netResult.success) {
                     // Depending on dockerode API, networks might not list containers directly 
                     // or containers inspect might have network info.
                     // Usually containers list has network settings. Let's simpler way:
                     // Group by Bridge/Host or custom networks found in container settings
                }

                // 3. Clear current graph? No, let's just append to avoid data loss, 
                // but user can delete if they want.
                
                // 4. Create Nodes
                const addedNodes = [];
                const centerX = 0;
                const centerY = 0;
                // Visualize in a circle
                const radius = 200 + (containers.length * 20); 
                
                // Add Central "Docker Host" node
                const hostId = Date.now();
                nodes.add({
                    id: hostId,
                    label: "\n<b>Docker Host</b>",
                    icon: { code: icons.server.code, color: '#ffffff', face: "'Font Awesome 6 Free'" },
                    x: centerX,
                    y: centerY,
                    _data: { name: 'Docker Host', type: 'server', color: '#ffffff' }
                });

                containers.forEach((c, index) => {
                    const angle = (index / containers.length) * 2 * Math.PI;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    
                    const state = c.state; // e.g. "running", "exited"
                    const color = getStatusColor(state);
                    const nodeId = Date.now() + index + 1;
                    
                    const node = {
                        id: nodeId,
                        label: `\n<b>${escapeHtml(c.name)}</b>\n${escapeHtml(state)}`,
                        x: x, 
                        y: y,
                        icon: { code: icons.docker.code, color: color, face: "'Font Awesome 6 Brands'" },
                        _data: { 
                            name: c.name, 
                            ip: '', 
                            type: 'docker', 
                            color: color, 
                            size: 45, 
                            opacity: 100,
                            dockerId: c.id,
                            dockerState: state
                        }
                    };
                    
                    addedNodes.push(node);
                    
                    // Create Edge to Host (Star Topology for now)
                    edges.add({
                        from: hostId,
                        to: nodeId,
                        color: { color: '#64748b' },
                        width: 1,
                        dashes: true // dashed line for virtual connection
                    });
                });
                
                nodes.add(addedNodes);
                updateSelects(); // Update dropdowns
                savePlan(false);
                network.fit({ animation: true });
                showToast(`${containers.length} containers générés`);
                
            } catch(err) {
                console.error(err);
                showToast("Erreur lors de la génération");
            }
        }

        async function generateDockerSchema() {
            if(!confirm("Cela va ajouter tous vos containers et tenter de les relier au réseau. Continuer ?")) return;
            
            try {
                // 1. Fetch Containers
                const response = await fetch('/api/docker/containers');
                const result = await response.json();
                
                if(!result.success) {
                    showToast('Impossible de récupérer les containers');
                    return;
                }
                
                const containers = result.containers;
                if(containers.length === 0) {
                    showToast('Aucun container trouvé');
                    return;
                }

                // 2. Fetch Networks (We need this to know who is connected to whom)
                // Note: We need to implement this endpoint or just rely on container info if simpler
                const netResponse = await fetch('/api/docker/networks');
                const netResult = await netResponse.json();
                const networksMap = {}; // NetworkName -> [ContainerIds]
                
                if(netResult.success) {
                     // Depending on dockerode API, networks might not list containers directly 
                     // or containers inspect might have network info.
                     // Usually containers list has network settings. Let's simpler way:
                     // Group by Bridge/Host or custom networks found in container settings
                }

                // 3. Clear current graph? No, let's just append to avoid data loss, 
                // but user can delete if they want.
                
                // 4. Create Nodes
                const addedNodes = [];
                const centerX = 0;
                const centerY = 0;
                // Visualize in a circle
                const radius = 200 + (containers.length * 20); 
                
                // Add Central "Docker Host" node
                const hostId = Date.now();
                nodes.add({
                    id: hostId,
                    label: "\n<b>Docker Host</b>",
                    icon: { code: icons.server.code, color: '#ffffff', face: "'Font Awesome 6 Free'" },
                    x: centerX,
                    y: centerY,
                    _data: { name: 'Docker Host', type: 'server', color: '#ffffff' }
                });

                containers.forEach((c, index) => {
                    const angle = (index / containers.length) * 2 * Math.PI;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    
                    const state = c.state; // e.g. "running", "exited"
                    const color = getStatusColor(state);
                    const nodeId = Date.now() + index + 1;
                    
                    const node = {
                        id: nodeId,
                        label: `\n<b>${escapeHtml(c.name)}</b>\n${escapeHtml(state)}`,
                        x: x, 
                        y: y,
                        icon: { code: icons.docker.code, color: color, face: "'Font Awesome 6 Brands'" },
                        _data: { 
                            name: c.name, 
                            ip: '', 
                            type: 'docker', 
                            color: color, 
                            size: 45, 
                            opacity: 100,
                            dockerId: c.id,
                            dockerState: state
                        }
                    };
                    
                    addedNodes.push(node);
                    
                    // Create Edge to Host (Star Topology for now)
                    edges.add({
                        from: hostId,
                        to: nodeId,
                        color: { color: '#64748b' },
                        width: 1,
                        dashes: true // dashed line for virtual connection
                    });
                });
                
                nodes.add(addedNodes);
                updateSelects(); // Update dropdowns
                savePlan(false);
                network.fit({ animation: true });
                showToast(`${containers.length} containers générés`);
                
            } catch(err) {
                console.error(err);
                showToast("Erreur lors de la génération");
            }
        }

        async function importFromDocker() {
            try {
                const response = await fetch('/api/docker/containers');
                const result = await response.json();
                
                if(!result.success) {
                    showToast('Docker non disponible');
                    return;
                }
                
                // Create a modal to select containers
                const containers = result.containers;
                if(containers.length === 0) {
                    showToast('Aucun container trouvé');
                    return;
                }
                
                let modal = document.createElement('div');
                modal.style.cssText = 'position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:1000; display:flex; align-items:center; justify-content:center;';
                
                let content = document.createElement('div');
                content.style.cssText = 'background:var(--panel-bg); padding:30px; border-radius:12px; max-width:600px; max-height:80vh; overflow-y:auto; border:1px solid var(--border-color);';
                
                let html = '<h2 style="margin-top:0; color:var(--text-primary);">Importer des Containers Docker</h2>';
                html += '<div id="docker-container-list" style="display:flex; flex-direction:column; gap:10px;"></div>';
                html += '<button class="btn-ghost" onclick="this.parentElement.parentElement.remove()" style="margin-top:20px; width:100%;">Fermer</button>';
                
                content.innerHTML = html;
                
                // Safely add containers with proper event handling (no XSS)
                const containerList = content.querySelector('#docker-container-list');
                containers.forEach(c => {
                    const statusColor = getStatusColor(c.state);
                    const containerDiv = document.createElement('div');
                    containerDiv.style.cssText = `padding:12px; background:rgba(0,0,0,0.3); border-radius:6px; border-left:3px solid ${statusColor}; cursor:pointer;`;
                    
                    const nameDiv = document.createElement('div');
                    nameDiv.style.cssText = 'font-weight:600; color:var(--text-primary);';
                    nameDiv.textContent = c.name;
                    
                    const infoDiv = document.createElement('div');
                    infoDiv.style.cssText = 'font-size:11px; color:var(--text-secondary);';
                    infoDiv.textContent = `Image: ${c.image} | État: ${c.state}`;
                    
                    containerDiv.appendChild(nameDiv);
                    containerDiv.appendChild(infoDiv);
                    
                    // Use event listener instead of inline onclick
                    containerDiv.addEventListener('click', () => {
                        addDockerContainer(c.id, c.name, c.state);
                    });
                    
                    containerList.appendChild(containerDiv);
                });
                modal.appendChild(content);
                document.body.appendChild(modal);
                
            } catch(err) {
                console.error(err);
                showToast('Erreur lors de l\'import Docker');
            }
        }
        
        function addDockerContainer(dockerId, containerName, state) {
            const color = getStatusColor(state);
            const node = {
                id: Date.now(),
                label: `\n<b>${escapeHtml(containerName)}</b>\n${escapeHtml(state)}`,
                _data: { 
                    name: containerName, 
                    ip: '', 
                    type: 'docker', 
                    color: color, 
                    size: 45, 
                    opacity: 100,
                    dockerId: dockerId,
                    dockerState: state
                },
                icon: { code: icons.docker.code, color: color, face: "'Font Awesome 6 Brands'" }
            };
            
            nodes.add(node);
            updateSelects();
            savePlan(false);
            showToast(`Container ${containerName} ajouté`);
            
            // Close modal
            document.querySelectorAll('body > div').forEach(el => {
                if(el.style.position === 'fixed' && el.style.zIndex === '1000') el.remove();
            });
        }
        
        async function refreshDockerStatus() {
            if(!selectedNodeId) return;
            
            const node = nodes.get(selectedNodeId);
            const d = node._data || {};
            
            if(!d.dockerId) {
                showToast('Container non lié');
                return;
            }
            
            try {
                const response = await fetch(`/api/docker/containers/${d.dockerId}/status`);
                const result = await response.json();
                
                if(!result.success) {
                    updateDockerStatusUI('disconnected', 'Non trouvé');
                    return;
                }
                
                const status = result.status;
                let state = 'disconnected';
                let text = status.state;
                
                if(status.running) {
                    state = 'running';
                    text = 'Running';
                } else if(status.paused) {
                    state = 'paused';
                    text = 'Paused';
                } else if(status.restarting) {
                    state = 'restarting';
                    text = 'Restarting';
                } else {
                    state = 'stopped';
                    text = 'Stopped';
                }
                
                updateDockerStatusUI(state, text);
                
                // Update node data AND COLOR
                d.dockerState = text;
                const newColor = getStatusColor(text);
                
                // Construct update object
                const updateObj = { 
                    id: selectedNodeId, 
                    _data: {...d, color: newColor},
                    icon: { ...node.icon, color: newColor }
                };
                
                nodes.update(updateObj);
                
            } catch(err) {
                console.error(err);
                updateDockerStatusUI('disconnected', 'Erreur');
            }
        }
        
        function updateDockerStatusUI(state, text) {
            const indicator = document.getElementById('docker-status-indicator');
            const statusText = document.getElementById('docker-status-text');
            
            const colors = {
                running: '#4ade80',
                stopped: '#f87171',
                paused: '#fbbf24',
                restarting: '#fbbf24',
                disconnected: '#94a3b8'
            };
            
            indicator.style.background = colors[state] || '#94a3b8';
            statusText.innerText = text;
        }
        
        async function dockerAction(action) {
            if(!selectedNodeId) return;
            
            const node = nodes.get(selectedNodeId);
            const d = node._data || {};
            
            if(!d.dockerId) {
                showToast('Container non lié');
                return;
            }
            
            try {
                const response = await fetch(`/api/docker/containers/${d.dockerId}/${action}`, {
                    method: 'POST'
                });
                const result = await response.json();
                
                if(result.success) {
                    showToast(result.message);
                    setTimeout(refreshDockerStatus, 500);
                } else {
                    showToast('Erreur: ' + result.error);
                }
                
            } catch(err) {
                console.error(err);
                showToast('Erreur de connexion');
            }
        }
        
        // --- UI ENHANCEMENT FUNCTIONS ---
        function updateStatistics() {
            const nodeCount = nodes.length;
            const edgeCount = edges.length;
            
            document.getElementById('stat-nodes').innerText = nodeCount;
            document.getElementById('stat-edges').innerText = edgeCount;
            
            // Count Docker containers by state
            let dockerRunning = 0;
            let dockerStopped = 0;
            
            nodes.get().forEach(n => {
                if(n._data && n._data.type === 'docker') {
                    const state = n._data.dockerState || '';
                    if(state.toLowerCase().includes('running')) {
                        dockerRunning++;
                    } else {
                        dockerStopped++;
                    }
                }
            });
            
            document.getElementById('stat-docker-running').innerText = dockerRunning;
            document.getElementById('stat-docker-stopped').innerText = dockerStopped;
        }
        
        function updateLegend() {
            const legendContent = document.getElementById('legend-content');
            legendContent.innerHTML = '';
            
            const types = new Set();
            nodes.get().forEach(n => {
                if(n._data && n._data.type) {
                    types.add(n._data.type);
                }
            });
            
            types.forEach(type => {
                const def = icons[type];
                if(def) {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    
                    const color = type === 'docker' ? DOCKER_BLUE : '#38bdf8';
                    item.innerHTML = `<i class="${def.fa}" style="color:${color};"></i><span>${type.charAt(0).toUpperCase() + type.slice(1)}</span>`;
                    legendContent.appendChild(item);
                }
            });
            
            if(types.size === 0) {
                legendContent.innerHTML = '<div style="font-size:10px; color:var(--text-secondary); text-align:center;">Aucun élément</div>';
            }
        }
        
        function toggleLegend() {
            const content = document.getElementById('legend-content');
            const icon = document.getElementById('legend-toggle-icon');
            
            if(content.style.display === 'none') {
                content.style.display = 'flex';
                icon.className = 'fas fa-chevron-up';
            } else {
                content.style.display = 'none';
                icon.className = 'fas fa-chevron-down';
            }
        }
        
        function updateMinimap() {
            const canvas = document.getElementById('minimap-canvas');
            if(!canvas || !network) return;
            
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * 2;
            canvas.height = rect.height * 2;
            ctx.scale(2, 2);
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const positions = network.getPositions();
            const nodeIds = Object.keys(positions);
            
            if(nodeIds.length === 0) return;
            
            // Find bounds
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            nodeIds.forEach(id => {
                const pos = positions[id];
                minX = Math.min(minX, pos.x);
                maxX = Math.max(maxX, pos.x);
                minY = Math.min(minY, pos.y);
                maxY = Math.max(maxY, pos.y);
            });
            
            const width = maxX - minX || 100;
            const height = maxY - minY || 100;
            const scale = Math.min((rect.width - 20) / width, (rect.height - 20) / height);
            
            // Draw nodes
            ctx.fillStyle = '#38bdf8';
            nodeIds.forEach(id => {
                const pos = positions[id];
                const x = (pos.x - minX) * scale + 10;
                const y = (pos.y - minY) * scale + 10;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fill();
            });
            
            // Draw edges
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 1;
            edges.get().forEach(edge => {
                const fromPos = positions[edge.from];
                const toPos = positions[edge.to];
                if(fromPos && toPos) {
                    ctx.beginPath();
                    ctx.moveTo((fromPos.x - minX) * scale + 10, (fromPos.y - minY) * scale + 10);
                    ctx.lineTo((toPos.x - minX) * scale + 10, (toPos.y - minY) * scale + 10);
                    ctx.stroke();
                }
            });
            
            // Draw viewport rectangle
            const viewport = network.getViewPosition();
            const viewScale = network.getScale();
            const containerRect = document.getElementById('network-container').getBoundingClientRect();
            
            const viewWidth = (containerRect.width / viewScale);
            const viewHeight = (containerRect.height / viewScale);
            
            ctx.strokeStyle = '#38bdf8';
            ctx.lineWidth = 2;
            ctx.strokeRect(
                (viewport.x - minX) * scale + 10,
                (viewport.y - minY) * scale + 10,
                viewWidth * scale,
                viewHeight * scale
            );
        }
        
        // Add keyboard shortcut for "F" to fit view
        document.addEventListener('keydown', function(e) {
            if(e.key === 'f' || e.key === 'F') {
                if(document.activeElement.tagName !== 'INPUT' && document.activeElement.tagName !== 'TEXTAREA') {
                    network.fit();
                    e.preventDefault();
                }
            }
        });
    </script>
</body>
</html>
